from abc import abstractmethod
from copy import deepcopy
from inspect import isclass
import importlib
import os

from stream_alert.shared.logger import get_logger

LOGGER = get_logger(__name__)


class AlertPublisherImporter(object):
    _is_imported = False

    @classmethod
    def import_publishers(cls):
        if cls._is_imported:
            return

        # Other way
        from stream_alert.shared.rule import import_folders

        import_folders('publishers')

        # for output_file in os.listdir(os.path.dirname(__file__)):
        #     # Skip the common base file and any non-py files
        #     if output_file.startswith(('__init__', 'core')) or not output_file.endswith('.py'):
        #         continue
        #
        #     full_import = '.'.join([
        #         'publishers',
        #         os.path.splitext(output_file)[0]
        #     ])
        #
        #     importlib.import_module(full_import)

        cls._is_imported = True


class AlertPublisher(object):
    """This is a decorator used to designate functions and classes as Publishers.

    During the annotation process, instances of the publishers will be instantiated and registered
    into the AlertPublisherRepository for ease of use.
    """

    def __new__(cls, class_or_function):
        # We have to put the isclass() check BEFORE the callable() check because classes are also
        # callable!
        if isclass(class_or_function) and issubclass(class_or_function, BaseAlertPublisher):
            # If the provided publisher is a Class, then we simply need to instantiate an instance
            # of the class and register it.
            publisher = class_or_function()
        elif callable(class_or_function):
            # If the provided publisher is a function, we wrap it with a WrappedFunctionPublisher
            # to make them easier to handle.
            publisher = WrappedFunctionPublisher(class_or_function)
        else:
            LOGGER.error(
                'Could not register publisher %s; Not callable nor subclass of BaseAlertPublisher',
                class_or_function
            )
            publisher = None

        if publisher:
            name = get_unique_publisher_name(class_or_function)
            AlertPublisherRepository.register_publisher(name, publisher)

        return class_or_function  # Return the definition, not the instantiated object


class BaseAlertPublisher(object):
    """Interface for a Publisher"""

    @abstractmethod
    def publish(self, alert, publication):
        """Publishes the given alert.

        Publishers are not intended to MODIFY the given publication; It is preferable to use
        deepcopy and to append on new fields onto the publication, in order to reduce the chance
        for bugs.

        As a general rule of thumb, published fields that are specific to a certain output are
        published as top-level keys of the following format:

        [output service name].[field name]

        E.g. "demisto.blah"

        Args:
            alert (Alert): The alert instance to publish.
            publication (dict): An existing publication generated by previous publishers in the
                series of publishers, or {}.

        Returns:
            dict: The published alert.
        """


class CompositePublisher(BaseAlertPublisher):
    """A publisher class that combines the logic of multiple other publishers together in series"""

    def __init__(self, publishers):
        self._publishers = publishers  # Type list(BaseAlertPublisher)

        for publisher in self._publishers:
            if not isinstance(publisher, BaseAlertPublisher):
                LOGGER.error('CompositePublisher given invalid publisher')

    def publish(self, alert, publication):
        new_publication = deepcopy(publication)

        for publisher in self._publishers:
            new_publication = publisher.publish(alert, new_publication)

        return new_publication


def get_unique_publisher_name(class_or_function):
    return '{}.{}'.format(class_or_function.__module__, class_or_function.__name__)


class WrappedFunctionPublisher(BaseAlertPublisher):
    """A class only used to wrap a function publisher."""

    def __init__(self, function):
        self._function = function

    def publish(self, alert, publication):
        return self._function(alert, publication)


class AlertPublisherRepository(object):
    """A repository mapping names -> publishers"""
    _publishers = {}

    @classmethod
    def register_publisher(cls, name, publisher):
        if not isinstance(publisher, BaseAlertPublisher):
            LOGGER.error('Registered publisher [%s] is not instance of BaseAlertPublisher.', name)
            return

        if name in cls._publishers:
            LOGGER.error('Publisher with name [%s] has already been registered.', name)
            return

        cls._publishers[name] = publisher

    @classmethod
    def get_publisher(cls, name):
        """Returns the subclass that should handle this particular service

        Args:
            name (str): The name of the publisher.

        Returns:
            BaseAlertPublisher|None
        """
        AlertPublisherImporter.import_publishers()

        try:
            return cls._publishers[name]
        except KeyError:
            LOGGER.error('Designated output service [%s] does not exist', name)

    @classmethod
    def all_publishers(cls):
        """
        Returns:
            dict
        """
        return cls._publishers

    @classmethod
    def create_composite_publisher(cls, publisher_names):
        """Assembles a single publisher that combines logic from multiple publishers

        Args:
            publisher_names (list(str)): A list of string names of publishers

        Return:
            CompositePublisher|DefaultPublisher
        """
        publisher_names = publisher_names or []
        publishers = []

        for publisher_name in publisher_names:
            publisher = cls.get_publisher(publisher_name)
            if publisher:
                publishers.append(publisher)

        if len(publishers) <= 0:
            # If no publishers were given, or if all of the publishers failed to load, then we
            # load a default publisher.
            default_publisher_name = 'publishers.community.generic.DefaultPublisher'
            return cls.get_publisher(default_publisher_name)

        return CompositePublisher(publishers)
