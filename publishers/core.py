from abc import abstractmethod
from copy import deepcopy
from inspect import isclass

from stream_alert.shared.logger import get_logger
from stream_alert.shared.rule import import_folders

LOGGER = get_logger(__name__)


class AlertPublisherImporter(object):
    _is_imported = False

    @classmethod
    def import_publishers(cls):
        if cls._is_imported:
            return

        import_folders('publishers')

        cls._is_imported = True


class AlertPublisher(object):
    """This is a decorator used to designate functions and classes as Publishers.

    During the annotation process, instances of the publishers will be instantiated and registered
    into the AlertPublisherRepository for ease of use.
    """

    def __new__(cls, class_or_function):
        # We have to put the isclass() check BEFORE the callable() check because classes are also
        # callable!
        if isclass(class_or_function) and issubclass(class_or_function, BaseAlertPublisher):
            # If the provided publisher is a Class, then we simply need to instantiate an instance
            # of the class and register it.
            publisher = class_or_function()
        elif callable(class_or_function):
            # If the provided publisher is a function, we wrap it with a WrappedFunctionPublisher
            # to make them easier to handle.
            publisher = WrappedFunctionPublisher(class_or_function)
        else:
            LOGGER.error(
                'Could not register publisher %s; Not callable nor subclass of BaseAlertPublisher',
                class_or_function
            )
            publisher = None

        if publisher:
            name = get_unique_publisher_name(class_or_function)
            AlertPublisherRepository.register_publisher(name, publisher)

        return class_or_function  # Return the definition, not the instantiated object


class BaseAlertPublisher(object):
    """Interface for a Publisher"""

    @abstractmethod
    def publish(self, alert, publication):
        """Publishes the given alert.

        Publishers are not intended to MODIFY the given publication; It is preferable to use
        deepcopy and to append on new fields onto the publication, in order to reduce the chance
        for bugs.

        As a general rule of thumb, published fields that are specific to a certain output are
        published as top-level keys of the following format:

        [output service name].[field name]

        E.g. "demisto.blah"

        Args:
            alert (Alert): The alert instance to publish.
            publication (dict): An existing publication generated by previous publishers in the
                series of publishers, or {}.

        Returns:
            dict: The published alert.
        """


class CompositePublisher(BaseAlertPublisher):
    """A publisher class that combines the logic of multiple other publishers together in series"""

    def __init__(self, publishers):
        self._publishers = publishers  # Type list(BaseAlertPublisher)

        for publisher in self._publishers:
            if not isinstance(publisher, BaseAlertPublisher):
                LOGGER.error('CompositePublisher given invalid publisher')

    def publish(self, alert, publication):
        new_publication = deepcopy(publication)

        for publisher in self._publishers:
            new_publication = publisher.publish(alert, new_publication)

        return new_publication


def get_unique_publisher_name(class_or_function):
    """Given a class or function, will return its fully qualified name.

    This is useful for assigning a unique string name for a publisher."""
    return '{}.{}'.format(class_or_function.__module__, class_or_function.__name__)


def publisher_registered(class_or_function):
    """Returns if the requested publisher has been registered"""
    return publisher_name_registered(get_unique_publisher_name(class_or_function))


def publisher_name_registered(publisher_name):
    return AlertPublisherRepository.has_publisher(publisher_name)


def is_valid_publisher_reference(class_or_function):
    """Returns TRUE if the given variable could be a publisher"""
    if isclass(class_or_function) and issubclass(class_or_function, BaseAlertPublisher):
        return True
    elif callable(class_or_function):
        return True

    return False


class WrappedFunctionPublisher(BaseAlertPublisher):
    """A class only used to wrap a function publisher."""

    def __init__(self, function):
        self._function = function

    def publish(self, alert, publication):
        return self._function(alert, publication)


class AlertPublisherRepository(object):
    """A repository mapping names -> publishers"""
    _publishers = {}

    @classmethod
    def register_publisher(cls, name, publisher):
        """Registers the publisher into the repository.

        Args:
             name (str): A unique name for this publisher
             publisher (BaseAlertPublisher): An instance of a publisher class

        Return:
            void
        """

        if not isinstance(publisher, BaseAlertPublisher):
            LOGGER.error('Registered publisher [%s] is not instance of BaseAlertPublisher.', name)
            return

        if name in cls._publishers:
            LOGGER.error('Publisher with name [%s] has already been registered.', name)
            return

        cls._publishers[name] = publisher

    @classmethod
    def get_publisher(cls, name):
        """Returns the subclass that should handle this particular service

        Args:
            name (str): The name of the publisher.

        Returns:
            BaseAlertPublisher|None
        """
        if cls.has_publisher(name):
            return cls._publishers[name]

        LOGGER.error('Publisher [%s] does not exist', name)

    @classmethod
    def has_publisher(cls, name):
        AlertPublisherImporter.import_publishers()
        return name in cls._publishers

    @classmethod
    def all_publishers(cls):
        """
        Returns:
            dict
        """
        return cls._publishers

    @classmethod
    def create_composite_publisher(cls, publisher_names):
        """Assembles a single publisher that combines logic from multiple publishers

        Args:
            publisher_names (list(str)): A list of string names of publishers

        Return:
            CompositePublisher|DefaultPublisher
        """
        publisher_names = publisher_names or []
        publishers = []

        for publisher_name in publisher_names:
            publisher = cls.get_publisher(publisher_name)
            if publisher:
                publishers.append(publisher)

        if len(publishers) <= 0:
            # If no publishers were given, or if all of the publishers failed to load, then we
            # load a default publisher.
            default_publisher_name = 'publishers.community.generic.DefaultPublisher'
            return cls.get_publisher(default_publisher_name)

        return CompositePublisher(publishers)
