import re
import time

from app_integrations.apps.app_base import StreamAlertApp, AppIntegration

class SlackApp(AppIntegration):
    """SlackApp will collect 2 types of event logs: access logs and integration logs.

    This base class will be inherited by different subclasses based on different
    event types.

    Access logs:
        contain information about logins

    Integration logs:
        contain details about your workspace's integrated apps
    """

    _SLACK_API_BASE_URL = 'https://slack.com/api/'

    @classmethod
    def _endpoint(cls):
        """Class method to return the endpoint to be used for this slack instance

        Returns:
            str: Path of the desired endpoint to query

        Raises:
            NotImplementedError: If the subclasses do not properly implement this method
        """
        raise NotImplementedError('Subclasses should implement the _endpoint method')

    @classmethod
    def _type(cls):
        raise NotImplementedError('Subclasses should implement the _type method')

    @classmethod
    def _subkey(cls):
        raise NotImplementedError('Subclasses should implement the _subkey method')

    @classmethod
    def service(cls):
        return 'slack'

    @classmethod
    def date_formatter(cls):
        """Slack API date format: unix epoch seconds"""
        return '%s'

    @classmethod
    def _required_auth_info(cls):
        """Required credentials for access to the workspace"""
        return {
                'auth_token': {
                    'description': ('The security token generated by installing an app. '
                        'This should be a string of characters beginning with xoxp-'),
                    'format': re.compile(r'^xoxp-[a-zA-Z0-9-]+$')
                    }
                }

    def _get_request_data(self):
        '''The Slack API takes additional parameters to its endpoints in the body of the request.
        Pagination control is one set of parameters.
        '''
        return {
                'count': '1000',
                'page': self._poll_count
                }

    def _gather_logs(self):
        """Gather log events.

        Returns:
            list: A list of dictionaries containing log events.
        """
        url = '{}{}'.format(self._SLACK_API_BASE_URL, self._endpoint())
        headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Bearer {}'.format(self._config.auth['auth_token']),
                }

        data = self._get_request_data()

        success, response = self._make_post_request(
                url, headers, data, False)

        if not success:
            LOGGER.exception('Received bad response from slack')
            return False

        if not u'ok' in response.keys() or not response[u'ok']:
            LOGGER.exception('Received error or warning from slack')
            return False

        if not self._subkey() in response.keys():
            LOGGER.exception('Received malformed response from slack')
            return False

        self._more_to_poll = int(response['paging']['pages']) > int(response['paging']['page'])

        if not self._more_to_poll:
            self._last_timestamp = int(time.time())

        return response[self._subkey()]


@StreamAlertApp
class SlackAccessApp(SlackApp):
    """An app that collects the logs from the team.accessLogs endpoint on Slack.

    There are a couple of quirks with this endpoint. It returns one entry per unique
    combination of user/ip/user_agent, with the values date_first and date_last
    indicating the first and most recent access with this combination. Entries
    are sorted by date_first descending, meaning that the entire log must be collected
    to ensure that all possible updates are available.

    Results are paginated, with the count parameter of the api dictating the max number
    of results per page (max 1000) and the page parameter of the api dictating which page
    is requested (max 100).

    The result of a successful api call is json whose outermost schema is

    {
      "ok":True,
      "login": [entries],
      "pagination": {
        "count": <number of entries per page>,
        "total": <total number of entries>,
        "page": <current page of results>,
        "pages": <total number of pages of results>
      }
    }

    Resource:
        https://api.slack.com/methods/team.accessLogs
    """
    _SLACK_ACCESS_LOGS_ENDPOINT = 'team.accessLogs'

    def __init__(self, config):
        super(SlackAccessApp, self).__init__(config)
        self._before_time = None
        self._next_page = 1

    @classmethod
    def _type(cls):
        return 'access'

    @classmethod
    def _endpoint(cls):
        return cls._SLACK_ACCESS_LOGS_ENDPOINT

    @classmethod
    def _subkey(cls):
        return u'logins'

    def _sleep_seconds(self):
        """Return the number of seconds this polling function should sleep for
        between requests to avoid failed requests. The Slack team.accessLog API
        has Tier 2 limiting, which is 20 requests per minute.

        Resource:
            http://api.slack.com/methods/team.accessLogs

        Returns:
            int: Number of seconds the polling function should sleep for
        """
        return 3

    def _gather_logs(self):
        """The team.accessLogs endpoint is not friendly for discovering changes.
        Specifically, the log entries are sorted descending by 'date_first',
        but new data will show in the `date_last` and `count` fields.

        The only clear way to get all new data from the log is to walk the entire
        set of entries and extract those whose `date_last` field is more recent
        than the previous invocation.

        Additionally, slack's pagination means that a maximum of 100,000 entries
        can be returned (1000 per page, 100 pages max). However, the `before` parameter
        permits walking further back.

        Returns:
            False on error, a list of dictionaries of log entries on success
        """
        url = '{}{}'.format(self._SLACK_API_BASE_URL, self._endpoint())
        headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Bearer {}'.format(self._config.auth['auth_token']),
                }

        data = {
                'count':'1000',
                'page': self._next_page
                }
        if self._before_time is not None:
            data['before'] = self._before_time

        success, response = self._make_post_request(
                url, headers, data, False)

        if not success:
            return False

        if not u'ok' in response.keys() or not response[u'ok']:
            return False

        if not self._subkey() in response.keys():
            return False

        '''if we hit the maximum possible number of returned entries, there may still be more
        to check. Grab the `date_first` value of the oldest entry for the next round'''
        if response['paging']['page'] == 100 and response['paging']['count'] == 1000:
            self._more_to_poll = True
            self._before_time = response['logins'][999]['date_first']
            self._next_page = 1
        else:
            self._more_to_poll = response['paging']['pages'] > response['paging']['page']
            self._next_page += 1

        results = [x for x in response['logins'] if x['date_last'] > self._last_timestamp]

        if not self._more_to_poll:
            self._last_timestamp = int(time.time())

        return results

@StreamAlertApp
class SlackIntegrationsApp(SlackApp):
    """An app that collects the logs from the team.integrationLogs endpoint on Slack.

    Results are paginated, with the count parameter of the api dictating the max number
    of results per page (max 1000) and the page parameter of the api dictating which page
    is requested (max 100).

    The result of a successful api call is json whose outermost schema is

    {
      "ok":True,
      "log": [entries],
      "pagination": {
        "count": <number of entries per page>,
        "total": <total number of entries>,
        "page": <current page of results>,
        "pages": <total number of pages of results>
      }
    }

    Resource:
        https://api.slack.com/methods/team.integrationLogs
    """
    _SLACK_INTEGRATION_LOGS_ENDPOINT = 'team.integrationLogs'

    @classmethod
    def _type(cls):
        return 'integration'

    @classmethod
    def _endpoint(cls):
        return cls._SLACK_INTEGRATION_LOGS_ENDPOINT

    @classmethod
    def _subkey(cls):
        return u'logs'

    def _sleep_seconds(self):
        """Return the number of seconds this polling function should sleep for
        between requests to avoid failed requests. The Slack team.integrationLog API
        has Tier 2 limiting, which is 20 requests per minute.

        Resource:
            http://api.slack.com/methods/team.integrationLogs

        Returns:
            int: Number of seconds the polling function should sleep for
        """
        return 3
