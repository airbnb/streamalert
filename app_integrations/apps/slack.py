import re

from app_integrations.apps.app_base import StreamAlertApp, AppIntegration

class SlackApp(AppIntegration):
    """SlackApp will collect 2 types of event logs: access logs and integration logs.

    This base class will be inherited by different subclasses based on different
    event types.

    Access logs:
        contain information about logins

    Integration logs:
        contain details about your workspace's integrated apps
    """

    _SLACK_API_BASE_URL = 'https://slack.com/api/'

    @classmethod
    def _endpoint(cls):
        """Class method to return the endpoint to be used for this slack instance

        Returns:
            str: Path of the desired endpoint to query

        Raises:
            NotImplementedError: If the subclasses do not properly implement this method
        """
        raise NotImplementedError('Subclasses should implement the _endpoint method')

    @classmethod
    def _type(cls):
        raise NotImplementedError('Subclasses should implement the _type method')

    @classmethod
    def _subkey(cls):
        raise NotImplementedError('Subclasses should implement the _subkey method')

    @classmethod
    def service(cls):
        return 'slack'

    @classmethod
    def date_formatter(cls):
        """Slack API date format: unix epoch seconds"""
        return '%s'

    @classmethod
    def _required_auth_info(cls):
        """Required credentials for access to the workspace"""
        return {
                'auth_token': {
                    'description': ('The security token generated by installing an app. '
                        'This should be a string of characters beginning with xoxp-'),
                    'format': re.compile(r'^xoxp-[a-zA-Z0-9-]+$')
                    }
                }

    def _get_request_data(self):
        '''The Slack API takes additional parameters to its endpoints in the body of the request.
        Pagination control is one set of parameters.
        '''
        return {
                'count': '1000',
                'page': self._poll_count
                }

    def _gather_logs(self):
        """Gather log events.

        Returns:
            list: A list of dictionaries containing log events.
        """
        url = '{}{}'.format(self._SLACK_API_BASE_URL, self._endpoint())
        headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Bearer {}'.format(self._config.auth['auth_token']),
                }

        data = self._get_request_data()

        success, response = self._make_post_request(
                url, headers, data, False)

        if not success:
            LOGGER.exception('Received bad response from slack')
            return False

        if not u'ok' in response.keys() or not response[u'ok']:
            LOGGER.exception('Received error or warning from slack')
            return False

        if not self._subkey() in response.keys():
            LOGGER.exception('Received malformed response from slack')
            return False

        self._more_to_poll = int(response['paging']['pages']) > int(response['paging']['page'])

        return response[self._subkey()]


@StreamAlertApp
class SlackAccessApp(SlackApp):
    """An app that collects the logs from the team.accessLogs endpoint on Slack.

    There are a couple of quirks with this endpoint. It returns one entry per unique
    combination of user/ip/user_agent, with the values date_first and date_last
    indicating the first and most recent access with this combination. Entries
    are sorted by date_first descending, meaning that the entire log must be collected
    to ensure that all possible updates are available.

    Results are paginated, with the count parameter of the api dictating the max number
    of results per page (max 1000) and the page parameter of the api dictating which page
    is requested (max 100).

    The result of a successful api call is json whose outermost schema is

    {
      "ok":True,
      "login": [entries],
      "pagination": {
        "count": <number of entries per page>,
        "total": <total number of entries>,
        "page": <current page of results>,
        "pages": <total number of pages of results>
      }
    }

    Additionally, the 'before' parameter of the api call does not appear to be
    functional. This has been confirmed with Slack's support.

    Resource:
        https://api.slack.com/methods/team.accessLogs
    """
    _SLACK_ACCESS_LOGS_ENDPOINT = 'team.accessLogs'

    @classmethod
    def _type(cls):
        return 'access'

    @classmethod
    def _endpoint(cls):
        return cls._SLACK_ACCESS_LOGS_ENDPOINT

    @classmethod
    def _subkey(cls):
        return u'logins'

    def _sleep_seconds(self):
        """Return the number of seconds this polling function should sleep for
        between requests to avoid failed requests. The Slack team.accessLog API
        has Tier 2 limiting, which is 20 requests per minute.

        Resource:
            http://api.slack.com/methods/team.accessLogs

        Returns:
            int: Number of seconds the polling function should sleep for
        """
        return 3

@StreamAlertApp
class SlackIntegrationsApp(SlackApp):
    """An app that collects the logs from the team.integrationLogs endpoint on Slack.

    Results are paginated, with the count parameter of the api dictating the max number
    of results per page (max 1000) and the page parameter of the api dictating which page
    is requested (max 100).

    The result of a successful api call is json whose outermost schema is

    {
      "ok":True,
      "log": [entries],
      "pagination": {
        "count": <number of entries per page>,
        "total": <total number of entries>,
        "page": <current page of results>,
        "pages": <total number of pages of results>
      }
    }

    Resource:
        https://api.slack.com/methods/team.integrationLogs
    """
    _SLACK_INTEGRATION_LOGS_ENDPOINT = 'team.integrationLogs'

    @classmethod
    def _type(cls):
        return 'integration'

    @classmethod
    def _endpoint(cls):
        return cls._SLACK_INTEGRATION_LOGS_ENDPOINT

    @classmethod
    def _subkey(cls):
        return u'logs'

    def _sleep_seconds(self):
        """Return the number of seconds this polling function should sleep for
        between requests to avoid failed requests. The Slack team.integrationLog API
        has Tier 2 limiting, which is 20 requests per minute.

        Resource:
            http://api.slack.com/methods/team.integrationLogs

        Returns:
            int: Number of seconds the polling function should sleep for
        """
        return 3
