from abc import abstractmethod
from copy import deepcopy
from inspect import isclass

from stream_alert.alert_processor.outputs.output_base import OutputDispatcher
from stream_alert.shared.logger import get_logger

LOGGER = get_logger(__name__)


class BaseAlertPublisher(object):
    """Interface for a Publisher"""

    @abstractmethod
    def publish(self, alert, publication):
        """Publishes the given alert.

        Publishers are not intended to MODIFY the given publication; It is preferable to use
        deepcopy and to append on new fields onto the publication, in order to reduce the chance
        for bugs.

        As a general rule of thumb, published fields that are specific to a certain output are
        published as top-level keys of the following format:

        [output service name].[field name]

        E.g. "demisto.blah"

        Args:
            alert (Alert): The alert instance to publish.
            publication (dict): An existing publication generated by previous publishers in the
                series of publishers, or {}.

        Returns:
            dict: The published alert.
        """

    @classmethod
    @abstractmethod
    def name(cls):
        """Returns a unique name for this publisher.

        Returns:
            str
        """


class CompositePublisher(BaseAlertPublisher):
    """A publisher class that combines the logic of multiple other publishers together in series"""

    def __init__(self, publishers):
        self._publishers = publishers  # Type list(BaseAlertPublisher)

        for publisher in self._publishers:
            if not isinstance(publisher, BaseAlertPublisher):
                LOGGER.error('CompositePublisher given invalid publisher')

    def publish(self, alert, publication):
        new_publication = deepcopy(publication)

        for publisher in self._publishers:
            new_publication = publisher.publish(alert, new_publication)

        return new_publication

    @classmethod
    def name(cls):
        return 'composite_publisher'


class WrappedFunctionPublisher(BaseAlertPublisher):
    """A class only used to wrap a function publisher."""

    def __init__(self, function, name):
        self._function = function
        self._name = name

    def publish(self, alert, publication):
        return self._function(alert, publication)

    def name(self):
        return self._name


class AlertPublisher(object):
    """This is a decorator used to designate functions and classes as Publishers.

    During the annotation process, instances of the publishers will be instantiated and registered
    into the AlertPublisherRepository for ease of use.
    """

    def __new__(cls, class_or_function):
        def fully_qualified_function_name(subject):
            module_name = subject.__module__
            function_name = subject.__name__

            return '{}.{}'.format(module_name, function_name)

        # We have to put the isclass() check BEFORE the callable() check because classes are also
        # callable!
        if isclass(class_or_function) and issubclass(class_or_function, BaseAlertPublisher):
            # If the provided publisher is a Class, then we simply need to instantiate an instance
            # of the class and register it.
            publisher = class_or_function()
            name = publisher.name()
        elif callable(class_or_function):
            # If the provided publisher is a function, we wrap it with a WrappedFunctionPublisher
            # to make them easier to handle.
            publisher = WrappedFunctionPublisher(
                class_or_function,
                fully_qualified_function_name(class_or_function)
            )
            name = publisher.name()
        else:
            LOGGER.error(
                'Could not register publisher %s; Not callable nor subclass of BaseAlertPublisher',
                class_or_function
            )
            publisher = None
            name = None

        if name and publisher:
            AlertPublisherRepository.register_publisher(name, publisher)

        return class_or_function  # Return the definition, not the instantiated object


class AlertPublisherRepository(object):
    """A repository mapping names -> publishers"""
    _publishers = {}

    @classmethod
    def register_publisher(cls, name, publisher):
        if not isinstance(publisher, BaseAlertPublisher):
            LOGGER.error('Registered publisher [%s] is not instance of BaseAlertPublisher.', name)
            return

        if name in cls._publishers:
            LOGGER.error('Publisher with name [%s] has already been registered.', name)
            return

        cls._publishers[name] = publisher

    @classmethod
    def get_publisher(cls, name):
        """Returns the subclass that should handle this particular service

        Args:
            name (str): The name of the publisher.

        Returns:
            BaseAlertPublisher|None
        """
        try:
            return cls._publishers[name]
        except KeyError:
            LOGGER.error('Designated output service [%s] does not exist', name)

    @classmethod
    def all_publishers(cls):
        """
        Returns:
            dict
        """
        return cls._publishers

    @classmethod
    def create_composite_publisher(cls, publisher_names):
        """Assembles a single publisher that combines logic from multiple publishers

        Args:
            publisher_names (list(str)): A list of string names of publishers

        Return:
            CompositePublisher|DefaultPublisher
        """
        publisher_names = publisher_names or []
        publishers = []

        for publisher_name in publisher_names:
            publisher = cls.get_publisher(publisher_name)
            if publisher:
                publishers.append(publisher)

        if len(publishers) <= 0:
            # If no publishers were given, or if all of the publishers failed to load, then we
            # load a default publisher.
            return cls.get_publisher('default')

        return CompositePublisher(publishers)

    @classmethod
    def assemble_alert_publisher_for_output(cls, alert, output, descriptor):
        """
        Args:
            alert (Alert):
            output (OutputDispatcher|None):
            descriptor (str):

        Returns:
            BaseAlertPublisher
        """

        alert_publishers = alert.publishers
        publisher_names = []
        if isinstance(alert_publishers, basestring):
            # Case 1: The publisher is a single string.
            #   apply this single publisher to all outputs + descriptors
            publisher_names.append(alert_publishers)
        elif isinstance(alert_publishers, list):
            # Case 2: The publisher is an array of strings.
            #   apply all publishers to all outputs + descriptors
            publisher_names += alert_publishers
        elif isinstance(alert_publishers, dict):
            # Case 3: The publisher is a dict mapping output strings -> strings or list of strings
            #   apply only publishers under the correct output key. We look under 2 keys:
            #   one key that applies publishers to all outputs for a specific output type, and
            #   another key that applies publishers only to outputs of the type AND matching
            #   descriptor.

            if isinstance(output, OutputDispatcher):
                # Order is important here; we load the output+descriptor-specific publishers first
                output_service_name = output.__service__
                described_output_name = '{}:{}'.format(output_service_name, descriptor)
                if described_output_name in alert_publishers:
                    publisher_name_or_names = alert_publishers[described_output_name]
                    if isinstance(publisher_name_or_names, list):
                        publisher_names += publisher_name_or_names
                    else:
                        publisher_names.append(publisher_name_or_names)

                # Then load output-specific publishers second
                if output_service_name and output_service_name in alert_publishers:
                    publisher_name_or_names = alert_publishers[output_service_name]
                    if isinstance(publisher_name_or_names, list):
                        publisher_names = publisher_names + publisher_name_or_names
                    else:
                        publisher_names.append(publisher_name_or_names)

        return cls.create_composite_publisher(publisher_names)
